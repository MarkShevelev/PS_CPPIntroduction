#include <iostream>

//Различные задачи при использовании указателей могут потребовать уточнений свойст переменной, хранящей адрес

//Константный указатель
void const_pointer() {
	int a = 3;
	int *inderect = &a; //переменная inderect может быть изменена
	std::cout << *inderect << std::endl;

	int b = 5;
	inderect = &b; //теперь указатель inderect хранит адрес b
	std::cout << *inderect << std::endl;

	//если необходимо запретить изменение указателя, например, чтобы не произвести случайного изменения, следует объявить переменную указателя константой

	//inderect_cv не может быть изменена
	int * const inderect_cv = &a; //обратите внимание на положение слова const 
	//inderect_cv = &b; //ошибка компиляции!

	//как и любая константа, неизменяемый указатель (константный указатель) должен быть инициализирован
	//int * const inderect_cv_uninit; //ошибка компиляции!
}

//Указатель на константу
void pointer_to_const() {
	//если некоторая переменная объявлена как константа, то адрес от этой переменной не получится сохранить в обычном указателе
	int const a_cv = 5;
	//int *inderect = &a_cv; //ошибка компиляции
	//если бы такое было разрешено, то посредством указателя можно было бы изменить значение константы, что может привести к неизвестному результату

	//для работы с константами необходимо объявлять специальные указатели - указатели на неизменяемые данные
	int const * inderect_to_cv = &a_cv;//обратите внимание на положение ключевого слова const
	const int * inderect_to_cv2 = &a_cv;

	//указатели на константу допускают чтение посредством разыменования, но не запись
	std::cout << *inderect_to_cv << " " << *inderect_to_cv2 << std::endl;

	//*inderect_to_cv = 5; //ошибка компиляции

	//хотя указатели на константы и не допускают изменения данных, хранящихся по адресу, но само значение переменной может быть заменено
	int const b_cv = 5;
	inderect_to_cv = &b_cv;
	std::cout << *inderect_to_cv << std::endl;

	//два типа константности могут быть совмещены
	int const * const cv_inderect_to_cv = &a_cv; //такой указатель нельзя изменить и нельзя изменить данные по адресу
	//cv_inderect_to_cv = &b_cv; //ошибка компиляции
	//*cv_inderect_to_cv = 7; //ошибка компиляции
}

//если функция ожидает указатель на константные данные, то может принимать и адрес изменяемых данных
void function_const_pointer(int const *cv) {
	std::cout << *cv << std::endl;
	//*cv = 7//ошибка компиляции
}

void inderect_function_test() {
	int a = 3;
	int const b = 5;

	function_const_pointer(&a);
	function_const_pointer(&b);
}

//В языке С++ для опосредованного доступа к памяти есть альтернативный вариант - ссылки
//ссылка - это специальное имя, которое можно присвоить уже существующим данным
void reference_example() {
	int a = 3; //обычная переменная, при объявлении которой выделяется память
	int &ref = a; //объявление ссылки ref
	//со ссылкой не связывается дополнительаня память! ссылка - это дополнительное имя для уже существующих данных
	//невозможно объявить неинициализированную ссылку
	int b; //нормальная неинициализированная переменная
	//int &ref2; //ошибка компиляции! неинициализированная ссылка

	//все действия над ссылкой - это действия над теми данными, с которыми она связана
	ref = 5; //перезапишется память, связанная с переменной a
	std::cout << a << std::endl;

	//обратите внимание, что никаких дополнительных операций с идентификатором ref совершать не нужно

	//нет никакой операции, которая позволила бы связать имя ref с другими данными, если единожды ссылка связана с какой-то переменной
	b = 7;
	ref = b; //перезапишется переменная a!!!
	std::cout << a << std::endl;

	++ref; //операция выполнется над переменной a
	std::cout << a << std::endl;

	//во многом ссылка похожа на константный указатель
	//однако со ссылкой не связывается отдельной памяти
	//в случае с указателем он имеет свою, отдельную памяти, где хранится адрес, и допускает дополнительные операции над этой памятью
	//ссылка не имеет своей памяти и дополнтительных операций
}

//ссылка позволяет получить опосредованный доступ к памяти, которая не принадлежит данному кусочку кода, без явного получения адреса
void referece_assignment(int &x) {
	x *= x;
}

void reference_function_test() {
	int a = 3;
	referece_assignment(a); //обратим внимание, никаких дополнительных операций не нужно указывать
	std::cout << a << std::endl;
}

//ссылки на неизменяемые данные
void reference_to_constant() {
	int const a = 3;
	//int &ref = a; //ошибка компиляции
	int const &ref_cv = a; //ссылка на константные данные (жаргонно: константная ссылка)
	const int &ref_cv2 = a; 

	//константная ссылка может именовать изменяемые данные
	int b = 1;
	int const &b_ref_cv = b;
	std::cout << b_ref_cv << std::endl;

	b = 2;
	std::cout << b_ref_cv << std::endl;

	//изменить же данные посредством ссылки на неизменяемые данные нельзя
	//b_ref_cv = 3;//ошибка компиляции
}

void pointer_inderect(int const *i_ptr) {
	std::cout << i_ptr << std::endl;
}

void reference_inderect(int const &i_ref) {
	std::cout << i_ref << std::endl;
}

int temporaty_return(int x) {
	return x + 1; //создаётся новый, временный объект и помещается на стек
}

//особые ситуации
void lifetime_examples() {
	int a = 1, b = 2;

	//при суммировании создаются новые, временные данные, от которых невозможно получить адрес
	//pointer_inderect(&(a + b));//ошибка компиляции!

	//ссылка может использовать ряд скрытых оптимизаций, которые позволяют передать псевдоним от временных данных
	reference_inderect(a + b); //успешно выводит сумму

	//константная ссылка может продлить время жизни объекта на стеке, который иначе должен был быть убран
	//int const * const i_ptr = &(temporaty_return(3)); //ошибка, невозможно взять адрес от временного объекта
	int const &i_ref = temporaty_return(a+b); //успешно!
	std::cout << i_ref << std::endl;
}

/*
i) Если функция принимает простые типы данных: char, int, double и т.п. Функция должна принимать копии данных
ii) Если данные имеют большой объём: string, vector и т.п. Функция должна принимать данные по константной ссылке
iii) Если данные требуют изменения, непрямого доступа Функция должна принимать их по ссылке
iv) Явную передачу в функцию адреса через указатель следует использовать только для совместимости с кодом языка C, например, при использовании массивов
*/

int main() {
	if (false) const_pointer();
	if (false) pointer_to_const();
	if (false) inderect_function_test();
	if (false) reference_example();
	if (false) reference_function_test();
	if (false) reference_to_constant();
	if (false) lifetime_examples();

	return 0;
}